私たちがこれから克服していかなければならないのは、複雑性(complexity)という新たな課題です。
しかしC言語をはじめ、多くのプログラミング言語には、プログラムが複雑になりすぎないように整理しながら記述できる仕組みが備わっています。
複雑性を克服するには、整理しながらプログラムを書くために構文を知り、活用する。

構造体(structure)とは,1つの変数の中に異なる型のデータを複数格納できる型の一種です。
構造体では、変数の箱の中に、さらに各データを納める箱が用意されます。
この内側の箱をメンバ(member)といい、それぞれに名前をつけて利用でします。

ステップ1 構造の定義
作りたい構造体がどのようなメンバを持っているかを定義する。
ステップ2 変数の生成
構造体自体の名前を決め、構造体変数の実体を生成する。
struct MONSTER {
  String name;
  int hp;
  int attack;
}
この記述はあくまでも、「このプログラムでは今後、String型のメンバname、int型のメンバhpとattackを持つ構造体をMONSTERと呼びます」と宣言しているに過ぎません。
ただし、この宣言は、「struct タグ名」型という名前の新しい型(構造体型)が利用できるようになるという効力を持っています。

構造体変数の宣言
struct タグ名 変数名;  //「struct タグ名」で1つの型名となる。

構造体の変数を指定した以降のプログラムでは、次の構文を使って、各メンバを通常の変数のように扱うことができます。

メンバのアクセス
構造体変数名.メンバ名

朱雀の構造体型変数を宣言した後では、朱雀のHPや攻撃力を次のように設定できる。
しかし、名前は設定できない点に注意。

suzaku.hp = 100;
suzaku.attack = 30;
suzaku.name = "朱雀"　//これはダメ

String型のメンバです。
このメンバに「朱雀」という文字列を代入する操作は、以前結んだ文字列型に関する第3の約束「初期化を除いて=で代入してはならない」に違反してしまいます。


struct MONSTER suzaku = {"朱雀", 100, 30};
or
struct MONSTER suzaku = {
  .name = "朱雀",
  .hp = 100,
  .attack = 30
};

typedef 型名 型につける別名;
typedef宣言は、構造体に限らず、C言語のどのような型に対しても別名を付けることができる構文です。

typedef struct MONSTER Monster;  //struct MONSTER型にMonster型という別名を付与
Monster suzaku;  //以降、Monster型を利用可能

structを省略した方が直感的にわかりやすいため、構造体はtypedef宣言と組み合わせて利用するパターンが一般的です。

列挙体は、構造体のようにタグ名を付けると列挙型として取り扱えるようになります。
例えば、次のような宣言により、型enum SIGNALや型Signalが利用可能になり、
その型の変数にはRED(0)やYELLOW(1)が代入できます。

enum SIGNAL {RED, YELLOW, GREEN};
typedef enum {RED, YELLOW, GREEN} Signal;

C言語の列挙型はint型の別名に過ぎません。
Signal型の変数に対して、REDやYELLOW、GREEN以外には整数であれば3や-10が代入できてしまう点には注意が必要です。
しかし、単純にint型で宣言するより意図が明確になるというメリットがあります。



