配列(array)は同じ種類の複数のデータを並び順で格納するデータ構造。
配列の中には、箱が連続して並んでいます。箱の一つ一つを要素(element)といい、変数の同じような型があり、データを格納できます。
配列の各要素の型は全て同じで、番号がついています。この要素の番号を添字(index)といい、0から始まる決まりになっています(1からではないことに注意)。
例えば、要素が5つある配列では、0番から4番までが存在し、5番の添え字を持つ要素はありません。
配列の最初の要素は0番から始まり、最後の添え字は全体の要素数より1つ小さな数となる。


配列宣言の文
　要素の型 変数名[要素数];

int gems[10];  //int型の要素が10個並んだ配列変数gems

配列要素へのアクセス
　配列変数名[添え字]

gemsの1番の要素に数値を代入するには、gems[1] = 3;のように記述する。
ここで、配列の最初の要素は0番の添え字を持つというルールを思い出してください。
gems[1] = 3;は配列gensの先頭ではなく、先頭から2番目の要素に3を代入することになります。


gems[添え字]と書くと各要素(小箱)を指す。
ちなみに、単にgemsと書くと配列全体(外側の大箱)を意味するんだ。


ところで、gems[10]という配列を宣言した場合、配列の要素数は10ですが、最初の要素を示す添え字は0であるため、最も大きい添え字の値は9になります。
宣言するときは[10]なのに、使うときには[9]までなんてちょっと紛らわしい。
これは、配列を宣言するときに書く[]と、配列の要素を指定するときに書く[]では、その意味も機能も似て非なるものだからです。
宣言の[]の中に書く数字は、何個の要素が必要なのかを個数でして指定するものです。
一方、配列を使うときの[]に書く数字は、何番目の要素なのかを位置で指定するものです。
そして、C言語では、位置を指定するときには0から始まるというルールを考慮する必要がある。
宣言時の[]と利用時の[]は全く別物だと思った方がいい。


配列の宣言と初期化
　要素の型 配列変数名[要素数] = {要素[0]の初期値,
           要素[1]の初期値,...};
※右辺を要素の型 配列変数名[]とすると、初期値に指定した数が要素数となる。

int a[5] = {0, 0, 0, 0, 0};

なお、この構文を利用する場合、[]の中に書く要素数の指定は省略することができ、{}内に記述した初期値の数を要素数として配列が定義されています。

int a[] = {0, 0, 0, 0, 0};  //配列は要素数5として定義される

また、要素数を具体的に指定した場合は、{}内の初期値の数が要素数に対して不足していても問題ありません。
足りない分は0で初期化される決まりになっています。

int a[5] = {20, 30, 10};  //要素[3][4]は0で初期化される

これを応用すると、全要素を0で初期化する処理は、さらに次のように書き換え可能です。全ての要素が0で初期化されます。

int a[5] = {0};  //従来から使える表記
int a[5] = {};  //最新のC言語で使える表記


配列変数gemsのデータ型は、C言語の世界ではint[10]型と呼ばれます。
要素数が重要でない場合は、int[]型またはint配列型ともいいます。
少し奇妙に感じるかもしれませんが、「int型の小箱を複数持つ配列の型」と解釈すればしっくりくるのではないでしょうか。

配列変数の型と要素の型は区別しておこう
　int gems[10];と宣言した場合
　・配列変数の型(gemsの型)：int[10]型
　・各要素の型(gems[0]の型)：int型


なお、int[10]型やfloat[3]型のように配列全体を表す型は配列型(array type)と呼ばれます。
「複数の値を1つの変数に入れるための型」という意味では構造体と同じであり、配列型と構造体型は集成対型(aggregate type)と総称されています。
int型とint[10]型は見た目は似ているが、実は似ても似つかない根本から異なる存在である。


配列型には、ソースコード上で型名が左右に分断されて登場することがあるという特徴があります。

  型の指定
 ↓       ↓
int gems[10];
     ↑
変数名の指定

型名が左右に分かれて記述されてしまうためにわかりにくいかもしれませんが、あまり拘らず、単なるルールだと割り切りましょう。
頭の中では正しい型int[10] gems;を常にイメージしてほしいが、ソースコード上では型を分裂して書く、と覚えよう。


可変長配列
原則として、C言語の配列宣言では、コンパイル時に要素数を確定させる必要があります。
int gems[10];のように要素数をリテラルで示す必要があり、int gems[n];のように、要素数に変数を記述できないのが原則です(nはconst定数でも許されませんが、列挙定数の場合許されます)。
近年のC言語規格では可変長配列(VLA:valiable length array)という機能が追加されたためこの制約は取り払われ、変数による要素数の指定も一応可能となっています。
しかし、可変長配列に対応しないコンパイラが存在したり、初期化構文が使えないなどのいくつかの制約も存在しますので注意してください。



これまで、[]の中、つまり配列の添え字には0や2といった固定の値(リテラル)を指定してきました。
しかし添え字には変数を用いることもできます。
たとえば、変数aに3という値が入っているときにgems[a]とすれば、前から4番目の要素にアクセスできます。
配列は添え字を変数で指定してこそ真価を発揮する道具。むしろ、添え字に固定値を書く機会の方が少ない。


forループで配列を回す
 for (int i = 0; i < 配列要素数; i++) {
   配列変数名[i]を使った処理
 }

このパターンは、配列の先頭から要素を1つずつ取り出して画面に表示するなど、全ての要素に同じ処理を行うときに用いると便利です。


パターン１の変形バージョンが、ループで配列の要素を集計するパターンです。
配列gemsにFIREの属性を持つ宝石がいくつあるのかを調べるためには、次のような処理を書く。

int count = 0;
for (int i = 0; i < 10; i++) {
  if (gems[i] == FIRE) {
    count++;
  }
}
printf("火の宝石の数は：%d\n", count);

ループを始める前に、集計結果を入れるための変数countを0で初期化して準備します。
for文などのループを回して要素を一つずつ調べ、もし値がFIREと一致すれば変数countを1増やします。
最終的にループが終了した段階で、countには配列gemsのうちFIREである要素の数が格納されているというわけです。
このような処理をカウント集計とも呼びます。

配列を集計する
int 集計結果の変数 = 0;
for (int i = 0; i < 配列要素数; i++) {
  配列変数名[i]を調べて集計結果の変数を書き換える処理
}


前節までに学習した配列は、1次元配列といいます。1次元配列に縦の並びを加えると、2次元配列になります。
2次元配列は、要素が縦横に並んだ表のようなものです。データを表のような形で扱いたい場合に使用すると便利です。
なお、2次元以上の配列を多次元配列と呼びます。業務アプリケーションの開発では用いる機会は少ないものの、
科学技術計算などでは広く利用されます。

2次元配列の宣言
　要素の型 配列変数名[行数][列数];

2次元配列の要素の利用
　配列変数名[行の添え字][列の添え字];


ループの入れ子の仕組み:
入れ子構造では「内側のループが1サイクルを終えるごとに、外側のループはまだ次のサイクルに進まない」。


配列の内容を全て表示したい場合であっても、printf()命令に配列変数そのものを引き渡すことはできません。
次のような記述をしたソースコードは、コンパイルはできますが想定外の動作をします。

int a[] = {10, 20, 30, 40, 50};
printf("%d ", a)


配列の計算や比較に関しても、同様に注意が必要です。
誤って配列変数そのものに算術演算子や関係演算子を使ってしまうと、想定外の動作をします。

int a[] = {10, 20, 30, 40, 50};
int b[] = {5, 15, 25, 35, 45};
int c[] = a + b;  //配列変数の計算はできない
if (a == b) {   //配列変数の比較はできない
  ...
}


構造体では例外的に許されていた操作、=演算子による代入(コピー)でした。
しかし残念ながら、配列の場合は代入することはできません。

int a[] = {1, 2, 3, 4, 5};
int b[5];
b = a;   //配列変数には代入できない

=演算子を使って配列変数に他の配列の内容を丸ごと代入(コピー)することはできない。


集成体型に丸ごと何かしようとする発想自体を捨てた方がいい。
そもそもprintf()などの命令や各種演算子は、基本的に値が1つしか格納されない基本型のためのものです。
構造体型変数や配列変数のように、さまざまなデータが複数格納されている変数に対して丸ごと計算や比較をすることができないのが原則です。
しかも配列は構造体と異なり、誤った操作をしてしまってもコンパイルエラーにならず、実行時に強制終了や想定外の動作をする可能性がある点にはさらに注意しましょう。
配列が「使うのは簡単、正しく使うのは難しい」とよく言われる所以です。配列使用時は常に頭の片隅に置いておくように。


配列宣言の文では型名を左右に分断して記述しますが、typedef宣言で別名を与える場合でもそのルールは変わりません。
従って、先ほどのtypedef宣言は「int[10]型にGemList型という別名を与える」ことを意味します。


typedef char String[1024];
この一文は、「要素数が1024個あるchar配列型」にString型という別名を与えているに過ぎません。
char型の変数には半角1文字分の情報を格納できます。
そのようなchar型の箱を複数並べて、文字列として扱ってきただけなのです。

これまで使ってきたString型は、単なるchar配列型の別名である。


