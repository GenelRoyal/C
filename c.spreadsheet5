もし条件が満たされなかった場合に別の条件で評価するには、else ifで始まるブロックをelseの前に挿入したif-else if-else構文を使います。
if (height >= 170) {
  size = 'L';
} else if (height >= 160) {
  size = 'M';
} else if (height >= 150) {
  size = 'S';
} else {
  size = '?';
}
一つのif文で3つ以上のルートに処理を分岐できるため、複数の条件式で評価したい場合に便利。else ifの数に制限はないので、条件式を必要なだけ続けて記述できる。
・複数のelse ifブロックを記述できるが、ifブロックより後ろ、elseブロックより前に記述。
・最後のelseブロックは、内容が空ならばelseごと省略できる。
だが、最後のelseブロックは、いずれの条件にも合致しなかった場合の動作(デフォルト動作)を記述しておく箇所です。
想定外の状況における動作は処理としてきちんと記述しておくべきです。したがってelseブロックは省略するべきではありません。
デフォルト動作の内容がないケースでも、コメントとして // do nothing などと記述し、作成者の意図をコードに残しましょう。
elseブロック内に ; と1行だけ書かれたコードは、「空文」と言い、何もしない処理を指示する文で、これも立派な文の一つ。do nothing コメントの代わりに使われることがある。


switch文に書き換えられるif文の条件
1.すべての条件式が==演算子で左辺と右辺が一致するかを比較する式である(<,>,!=が使われていない)。
2.比較する値が整数(char,short,int,long型)や整数に類する型(bool型、列挙定数)であり、小数や文字列ではない。

break文がなければ次のcaseブロックも続けて実行されるswitch文での動作をフォールスルー(fall through)と言います。


C言語
C言語

100%
10
D10

列挙定数とconst定数の微妙な違い
列挙体により定められた定数とconst指定によるint型定数とは、
厳密には取り扱いが異なります。
例えば、C言語の使用ではswitch文のcaseラベルにはリテラルか列挙定
数の記述しか認められず、constによる定数の使用は許されません。
一部のコンパイラではcaseラベルへのconst定数の利用を許容します
が、コンパイラの種類や設定によっては警告やエラーを出すものがあります。
 
 
 	
列挙定数とconst定数の微妙な違い
列挙体により定められた定数とconst指定によるint型定数とは、
厳密には取り扱いが異なります。
例えば、C言語の使用ではswitch文のcaseラベルにはリテラルか列挙定
数の記述しか認められず、constによる定数の使用は許されません。
一部のコンパイラではcaseラベルへのconst定数の利用を許容します
が、コンパイラの種類や設定によっては警告やエラーを出すものがあります。


do-while文は、まず実行してから条件式を評価します。

while (temp > 25) {
  temp--;
}

do {
  temp--;
} while (temp > 25); //while文とは異なりセミコロンが必要

while文とdo-while文のいちばんの違いは、「必ず実行されるループの回数」だ。
while文はブロックを実行する前に条件判定を行うので(これを前置判定と言います)、最初から条件式の判定結果が偽になっ
ている場合には一度もブロックの内容を実行しません。
一方、do-while文はブロックを実行した後に条件判定を行うので(これを後置判定と言います)、必ず最低1回はブロックの内容が実行されます。

①初期化処理
forによる繰り返しを始める前に、最初の1回だけ実行される文です。通常、何周目のループなのかを記録する変数の宣言や初期化を行います。このような変数をループ変数と言います。
②繰り返し条件
このループを継続するか否かを判定する条件式です。ブロックの内容を実行する前に毎回評価されます。評価結果が真である間は、ブロックが繰り返し実行されます。for分やwhile文と同じ前置判定の繰り返し構文です。
③繰り返し処理
ブロックを閉じる波括弧まで処理が到達した直後に自動的に実行される文です。
通常、ループ変数の値を1だけ増やす文を書きます。

ループ変数の名前は自由に決められます。1文字程度の短い変数名が選ばれることが多いようです。
ループ変数は変数の一つなので、ブロック内の計算や表示などの処理に使えます。
ifブロック内で宣言した変数がブロック外では使えないように、for文の初期化処理で宣言したループ変数もfor文のブロック内でのみ有効です。
for文を抜けるとループ変数は消滅してしまいますので注意が必要です。

//ループ変数を1から開始する
for (int i = 1; i < 10; i++) {...}

//ループ変数を2ずつ増やす
for (int i = 0; i < 10, i += 2) {...}

//ループ処理を10から1ずつ1まで減らす
for (int i = 10, i > 0, i--) {...}

//ループ変数を初期化しない
for (; i < 10; i++) {...}

//繰り返し時処理を行わない（無限ループ）
for (int i = 0; i < 10;) {...}



分岐したブロックの中でさらに分岐したり、繰り返し処理の中で分岐したりという構造になります。
このような多重構造を入れ子とネストと言います。

処理によっては、繰り返しを最後まで行わずに途中で中断したいことがあります。
その場合は、break文とcontinue文という2種類の方法によって中断できます。
break文はループそのものを中断し、ループの次に記述された処理へと進みます。
continue文は現在の周回だけを中断してループの先頭へ戻り、次の周回のループを継続します。

強制的に停止しない限り永久に繰り返しを続ける制御構造を永久ループ(infinite loop)と呼びます。
①while (true) {...}  //trueは1でも良い
②for ( ; ; ) {...}

C言語では、ソースコード中の任意の場所にラベル(label)を書いて印を付けられます。
ラベル名は開発者が自由に設定できます。goto文でラベルを指定すると、そのラベルの位置が次に実行される文になるのです。

多用するとプログラムの構造が複雑でわかりにくくなり、原因の特定が非常に難しい深刻なバグを作ってしまうリスクが知られています。
処理構造が複雑に絡んだプログラムをスパゲッティプログラムと呼ぶ。
C言語で書かれたプログラムの複雑なバグは、突然の強制終了やセキュリティ事故につながる可能性がある。だからこそgoto文は相応のリスクを覚悟して使うべき道具なのです。

諸刃の剣であるgoto文をあえて使用すべき状況
①深くネストしたループを一気に脱出するため
②後片付けを必要とするエラー処理を記述するため

