1つのプログラムを複数の部品に分けて開発できる、部品化のしくみを備えています。
本章で学ぶ関数(function)は、複数の文をまとめて1つの処理として名前を付けたもので、部品の最小単位になります。
処理を機能単位で関数に分割すれば、プログラムの大局を見通せるようになって処理全体の把握が非常に楽になるのです。
また、処理を関数に分割しておけば、「表示がおかしい」などの不具合が見つかった場合、それを担当する関数だけを調べれば良いため、修正の範囲を限定できるメリットがあります。
さらに、関数は繰り返し使用できるので、同じ処理を何度も書く手間がなくなり、改良や修正も効率的に行うことができるようになります。

関数利用によるメリット
・プログラムの見通しが良くなり、処理全体を把握しやすくなる。
・機能単位で処理を記述するため、修正範囲を限定できる。
・同じ処理を1つの関数にまとめることで、作業効率が上がる。


void 関数名(void)
{
  関数が呼び出された時に実行する処理
}

※関数を定義すると、それより下の部分のソースコードでその関数を利用できる。
※関数定義の中で、別の関数を定義してはならない。


#include <stdio.h>

void hello(void) //関数の表明
{
  printf("こんにちは\n");  //関数の処理内容
}

voidとは、「無」や「何もない」ことを意味する英単語ですが、詳細は後ほど。今は気にする必要はありません。


関数の呼び出し
関数名();

C言語には、関数がいくつか定義されていても、必ずmain関数から動き始めるというルールがあります。
関数は定義しただけでは実行されません。関数呼び出しの行を削除すると「こんにちは」は表示されなくなります。


立場1 関数を定義する立場
立場2 関数を呼び出す立場

「hello関数を定義する自分」と「main関数の中でhello関数を呼び出す自分」とをあたかも別人物として捉えてプログラムを書くことが、C言語プログラミングの上達の近道です。
関数を定義する人は、関数を呼び出す人のことを考えて関数を作成するべきです。
関数の内容が想像しやすい名前であり、その関数を呼び出す側のプログラムを眺めた時にも、何の処理をしているか読み取れる必要がある。
処理内容のわかりにくさは、関数のそれを利用する側の処理へと波及し、やがてプログラム全体へと拡大してしまう。

int main(void)
{
  hello(); //ここでは挨拶を表示させている…と推測できる
  saveToFile(); //ここではファイルに保存している…と推測できる
  aaa(); //ここでは何をしているのか想像がつかない！
}

関数名は、関数を定義する人だけでなく、関数を呼び出す人にも大きな影響を与えます。
自分ひとりだけでなく、同じチームの仲間の開発効率をも左右するため、非常に重要なことなのです。

関数定義の1行目は特に重要な部分です。
ここには、この関数を定義する人と呼び出す人の双方に関わる重要な情報が記述されます。
関数を作る側は、「この関数はこの名前で、このように呼び出してほしい」と1行目で表明します。
関数を呼び出す側は、1行目に記述された情報を見て、「この関数はこの名前を使ってこのような形で呼び出せば良い」と理解します。
つまり、関数を定義する人、関数を呼び出す人の2つの立場の接点に当たるのが、この関数定義の1行目であるというわけです。

関数定義の1行目は人と人との接点
関数定義の1行目は、定義する人と呼び出す人の接点となる重要な情報が書かれる。

一方、関数定義の2行目以降に書く関数ブロックは、1行目ほどの重要性はありません。
関数を呼び出す人は、「正しい形で呼び出しさえすれば、きちんと仕事してくれる」という前提のもとに関数を呼び出します。
関数が内部でどのように処理するかまではいちいち気にする必要がないのです。


ところで、関数はmain関数以外からも呼び出すことができます。
funcAがfuncBを呼び出しています。
処理の流れとして、main関数→funcA→funcBの順に実行されます。


プロトタイプ宣言
戻り値の型 変数名(引数リスト);

※関数宣言の1行目と同じ内容を記述し、末尾にセミコロンを付ける。

プロトタイプ宣言には関数の処理内容は書かれませんが、関数の存在が表明されるため、プロトタイプ宣言を記述した行以降で関数を呼び出せるようになります。

「このソースコードにはfuncAとfuncBが存在します」とコンパイラに伝えています。
通常であれば、「funcAなんていう関数は定義されていない！呼び出せない！」と怒り始めるコンパイラも、「後ろの方で定義されるんだろう」と見込んでエラーを出しません。



関数を呼び出す際に、呼び出し元から値を渡すことができます。
渡される値を引数(argument)といい、呼び出された関数では、渡された値を受け取って処理に利用できます。


カッコの中に、整数の1が指定されています。
これは、hello関数を呼び出す際に、併せてその値を引き渡すことを意味します。

関数名の後ろのカッコの中で、int型の変数noを宣言しています。
hello関数が呼び出されると、渡された値が変数noに自動的に代入され、関数内で使用できるようになります。
このソースコードでは画面に表示する内容の判定に引数が使われ、1が渡された場合には、結果として「岬さん、こんにちは」と出力されます。

何も渡さない時でもカッコ自体は書く必要があり、()は「何も渡さない」ことを意味します。



引数は1つだけじゃなくて2つ以上渡すこともできる、これができると、もっと便利に感数を使えるようになる。

引数として渡す値が複数ある場合、値をカンマで区切って指定します。
また、関数側でも、変数をカンマで区切って宣言します。

引数が複数の場合、関数定義の1行目で宣言されている変数と、引数として渡す値の型と順序を揃えておかなければならない点に注意してください。
引数と変数の型が一致していなかったり、受け取るべき箱がなかったりするとコンパイルエラー発生します。


引数のある関数の定義
void 関数名(引数リスト)
{
  関数が呼び出されたときに実行する処理
}
※引数リストには、型 引数名をカンマで区切って指定する。

引数のある関数の呼び出し
関数名(引数リスト);
※引数リストには、リテラルや変数をカンマで区切って指定する。



関数定義に記述する引数は、関数が受け取る引数のデータ型と変数名を定めているもので、厳密には仮引数と言います。
hello関数で例えるなら、「私を呼び出すときは、int型の情報を持ってきてくださいね。私の中ではnoという変数名で取り扱います」と自己紹介をしているようなものです。
実際にどのような値が入って動作するかは、関数が呼び出されるまで分かりません。
一方、関数呼び出しに書かれる引数は、関数に仕事を依頼するにあたって、「この値を使って作業してください」と具体的な情報を引き渡しているもので厳密には実引数と言います。


仮引数が0個、つまり引数を受け取らない関数の定義では、うっかりvoidの記述を忘れて次のようなコードを書いてしまうことがあります。

#include <stdio.h>

void hello() //引数にvoidを書き忘れている
{
  printf("こんにちは\n");
}

int main(void)
{
  hello();
  return 0;
}

このプログラムはコンパイルも成功しますし、実行もできます。しかし次の理由から、このような関数定義はすべきではありません。
・C言語の仕様バージョンによってはvoidの省略は認められていないため、エラーや警告の原因になる可能性がある。
・プロトタイプ宣言でvoidを省略すると、任意の個数の引数を許容する意図になる。コンパイルチェックも行われないため、非常にリスクの高いコードになってしまう。



add関数には足し算の計算だけを依頼して、画面表示は呼び出した側が行いたい場合、呼び出し側はadd関数の実行後に足し算の結果を受け取る必要があります。
このように、呼び出した関数による処理結果の情報を呼び出し元に返して欲しい場面はよくあり、この時に使われるのが、関数の戻り値(または返り値)と呼ばれる仕組みです。

戻り値を返す関数の定義
戻り値の型 関数名(仮引数リスト)
{
  関数が呼び出された時に実行する処理
  return 戻り値;
}

関数名の直前にはこれまでvoidを記述していましたが、これは「戻り値がない関数」の表明でした。
ここでvoidではなくデータ型を指定すると、その型の戻り値があることを表しています。
例えば、intを記述すると、実行後にint型の値を1つ返す関数だと表明できます。

次に、関数の処理内容の最終行、returnの部分に着目。
これはreturn文といい、多くの場合、関数の処理の最も後ろに書かれます。
関数の実行を終了する役割を持つとともに、呼び出し元に返す具体的な値をここに指定できます。
関数主義でint型の値を1つ返すと表明したら、必ずreturn文で整数値を１つ返さなければなりません。
次のコードは、この構文を使って、画面表示は行わずに足し算の結果を呼び出し元に返すadd関数を定義しています。

#include <stdio.h>

int add(int x, int y) //2つの引数を受け取って処理し、１つのint値を返すことを表明
{
  int ans = x + y;
  return ans; //変数ansに入っている合計値を返す
}

int main(void)
{
  int year = 2025;
  add(year, 4);
  add(year, 50);
  
  return 0;
}


return文には、次の3つの注意点があります。

・戻り値を持たない関数のreturn文は省略可能
戻り値のない関数では、return文を書かなくてもかまいません。あえて記述する場合は、return;と書きます。

・戻り値は1つしか返せない。
引数は複数の値を受け取ることができますが、戻り値は１つしか返せません。
当然、return文にも値は１つしか指定できません。
どうしても複数の値を返す必要がある場合は、これまでに紹介してきた配列や構造体などの集成体型を使います。

・処理の途中でもreturn文を記述できるが...
関数の最終行ではなく、処理の途中にreturn文を記述することができます。
しかし、return文には、戻り値を返すだけでなく、関数の実行を終了して呼び出し元に制御を返す機能がある点に注意が必要です。
もし関数の途中でreturn文を使うと、それより下に書かれた文は実行されません。

#include <stdio.h>

int add(int x, int y)
{
  int ans = x + y;
  return ans;
  
  printf("addを終了します\n"); //この文は実行されない
}
//main関数は省略



戻り値を返さないこれまでのadd関数は、足し算をして画面に表示する処理を担当していますが、今回の変更で足し算だけを行う関数になりました。
add関数の立場としては、合計の結果は戻り値として返すから、あとは呼び出し元が表示するなりファイルに保存するなりご自由に、というわけです。
呼び出し元では戻り値を受け取る記述をする必要がある。

ある関数を呼び出し、かつ戻り値を受け取るためには、関数の呼び出しに次の構文を使います。

関数を呼び出して戻り値を受け取る
 戻り値を受け取る変数名 = 関数名(引数リスト);
※戻り値を受け取るための変数名を定義するイメージ



 =や+などの様々な種類の演算子があり、それぞれ処理の優先順が決められていました。
また、演算子は周囲のオペランドを巻き込んで、何かの結果の値に「化ける」という特性を持っています。
そして関数呼び出しも、実は()演算子の働きによるものなのです。

関数呼び出し演算子
 関数名(引数リスト)
※()の中に指定されたものを引数として関数を実行し、実行結果の戻り値に「化ける」。
※優先順位は16段階中の「最高」で、他のどの演算子よりも優先して動作する。

()演算子の存在を知ると、ans = add(100, 20);という式の本質が見えてきます。
この式には=演算子と()演算子の2つが存在しますが、最高の優先順位を持つ()演算子がまず処理され、add関数の実行により、右辺が120という値に化けます。
その結果、ans = 120; という単純な代入式になり、変数ansに120が代入されるというカラクリなのです。
結局、ただの代入文だと考えれば、=演算子の左辺と右辺は間違いようがないね。

int n = add(add(10, 20), add(30, 40)); //30と70に化ける
int p = gems[add(pos, 3)]; //変数posに3を加算した値に化ける